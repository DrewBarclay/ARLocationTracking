% Rangefinding

\chapter{Rangefinding} % Main chapter title

\label{Rangefinding}

%----------------------------------------------------------------------------------------

\section{Overview}
 Rangefinding is the act of determining the distance between two things.
 
\subsection{The System}
The rangefinding subsystem is comprised of \textbf{nodes} in a network, each of which is capable of sending and receiving wireless signals.

(PUT IN A DIAGRAM OF A NETWORK AND RANGES HERE)

Each node is either an \textbf{anchor} or a \textbf{tag}. Both tags and anchors use essentially the same hardware and code, but anchors are assumed to be stationary while tags are mobile. Stationary nodes are required so as to provide a consistent frame of reference for other nodes when calculating positions later on. More information on this can be found in !!!TO-DO INSERT LABEL!!!.

The rangefinding subsystem's purpose is to determine the distances between every pair of nodes in the network. With this data, the position calculation subsystem can then determine the positions of every anchor and tag in 3D space.

\subsection{Rangefinding}
Rangefinding is done wirelessly. The underlying concept is that if we can calculate the times at which we send and receive a signal, then - since light travels at a fixed speed - we can determine the distance the signal traveled, which is the distance between the nodes. 

The basic method is this: 
\begin{enumerate}
	\item Each node broadcasts a message to every other node, and every node responds. 
	\item The time it took for the message to travel from one node to another and then back (minus the time spent processing the received messages) is calculated.
	\item With some simple math involving the speed of light the distance between the nodes is calculated. 
\end{enumerate}

This method of calculating range is known as \textbf{time-of-flight} (TOF).

Each node is comprised of a DWM1000, can send wireless signals, and an Arduino microcontroller.

\subsection{Requirements}
There are a number of useful characteristics a rangefinding system should have:
\begin{itemize}
	\item Ranges should be accurate and not very noisy.
	\item Ranges should be calculated at a high frequency. If they are not, then we cannot calculate positions quickly and moving objects will have their positions displayed inaccurately.
	\item The system should be able to cover a large area. 
	\item The system should be robust to nodes entering/leaving the network. 
\end{itemize}

It will be demonstrated how we sought to satisfy these criteria.

(TODO TALK ABOUT WHAT IS COMING UP IN THE REST OF THE CHAPTER)

\section{Time-of-Flight}
This section briefly covers the math behind time-of-flight range calculations. For something more in-depth, the DWM1000 User Guide (INSERT CITATION HERE) has a comprehensive write-up of the different ways wireless ranging can be performed.

\subsection{Basic Two-Way Ranging}
In the case where there are two nodes communicating with each other, one can calculate the time it takes a signal to propagate between them, $t_p$, as:

\[
	t_p = \frac{t_{round} - t_{process}}{2}
\]

A diagram displaying this can be found in !!INSERT HERE!!.

\subsection{Asymmetric Two-Way Ranging}
Because the clocks of two nodes may not pass time at the same rate, the above equation will not be as accurate as possible. The DWM1000 User Guide presents, without proof, the following equation for more accurate rangefinding:

\[
	t_p = \frac{round_1  round_2 - reply_1 reply_2}{ round_1 + round_2 + reply_1 + reply_2}
\]

$round_1$, $round_2$, $reply_1$, $reply_2$ are respectively the total times taken (EXPLAIN BETTER HERE). See (INSERT FIGURE HERE).
 
A possible proof of this equation can be found in (INSERT APPENDIX THING HERE).

\section{Wireless Communications}
At the start of the project, it was determined that a technology would need to be chosen to handle wireless communications for ranging purposes. A number of options were considered. The ideal technology would:
\begin{itemize}
	\item Be inexpensive.
	\item Have good range for in-door use.
	\item Allow for extremely precise measurements of time. Due to the speed of light, a nanosecond of error in timing calculations would lead to approximately 30cm of error in the calculated distance.
	\item Be small. As tags are attached to cellphones, they must be small.
\end{itemize}

\subsection{Bluetooth in Phones: A Failed Approach}
Originally, the goal was to use Bluetooth for ranging. The reason for this was that Android cellphones, which usually have Bluetooth transceivers, could be used for tags and anchors. This would save a large amount of time, as cellphones include batteries, are easy to program, and almost everyone has one (which would make letting people use our project as easy as downloading an app). We would just need to put a few phones running our app around a room, and we'd get ranging.

Unfortunately, it became clear early on that Bluetooth - specifically, Bluetooth used on Android cellphones - was not suitable. The time it took to send a Bluetooth message itself through the Android OS suffered massive variance of milliseconds (ADD IN APPENDIX CITATION WITH OUR CODE?), which would lead to 300 km of error in calculated distances! Android does not have any guarantees on timing, and does not allow low-level programming access to its internals (even when rooted). As such, we abandoned the idea of using phones as nodes.

\subsection{Ultra-wideband and the DWM1000}
After doing some research, we discovered the Decawave DWM1000 ultra-wideband transceiver. This chip is advertised as specifically being suited for ranging applications. It uses ultra-wideband technology rather than Bluetooth, Wi-Fi, or similar technologies.

Ultra-wideband, in contrast to Wi-Fi and other radio technologies, occupies a large bandwidth and transmits information via high-bandwidth pulses. Ultra-wideband is suited to tracking applications due to its resistance to multipath propagation, a phenomenon where signals reflect off of surfaces and thus reach the antennae via multiple paths (causing interference). An in-depth look at ultra-wideband is beyond the scope of this report, but interested readers might look more at (INCLUDE SOURCES HERE!!!).

The DWM1000 is advertised as:
\begin{itemize}
	\item Allowing one to locate objects with up to 10cm accuracy.
	\item Having a range of up to 290m.
	\item Having a data rate of up to 6.8Mb/s.
	\item Having a small physical size. 
\end{itemize}

Because these qualities satisfied our requirements, the DWM1000 was chosen for the foundational technology of the ranging part of the project. 

\section{Design of the Hardware}
The hardware design for tags is an Arduino Pro Mini 3.3V connected to a DWM1000 over a PCB. 

\subsection{The Microcontroller}
To interface with the DWM1000, a microcontroller was needed. The Arduino Pro Mini 3.3V was chosen because:
\begin{itemize}
	\item Group members had previous experience with programming Arduinos.
	\item It was inexpensive.
	\item It worked off of 3.3V power, which was what the DWM1000 required. This obviated the need for voltage stepping.
	\item It is capable of floating point math, which is useful for asynchronous two-way ranging. As well, barely any processing power or RAM was needed. Each microcontroller only needed to hold a small number of timestamps, so the small amount of memory and slow processor was not important.
	\item Small physical size. As tags are attached to cellphones, they must be small.
	\item Batteries would not be needed to power tags, since power could be delivered via USB from the cellphone. This further simplified the design and kept costs low.
\end{itemize}

The only real downside of the Pro Mini was that it required a lot of soldering. 

\subsection{The PCB}
Several designs were considered for the PCB connecting the Arduino and DWM1000. The most important factor was size. A PCB was constructed only for the tags, and anchors - which did not need to be reduced in size - were left in breadboard form in order to save costs and time. Making alterations to the PCB design to allow for a barrel jack power adapter (the only distinguishing feature between tags and anchors) would, however, have been extremely simple.

The first design idea we tried was to place the Arduino and DWM on top of each other, resulting in the smallest possible size. See (INSERT FIGURE HERE). However, the physical dimensions of the two components made this impossible. The other possibility was to place each component on opposite sides of the PCB (INSERT FIGURE HERE), but the Arduino's design demanded breakout headers to solder it into the board, which meant the PCB had to have holes drilled. This essentially ran into the same problem as with the original.

The second idea was to make two PCBs. The Arduino would connect to a PCB above it, and that PCB would connect to a board above it with the DWM1000 it. Because it was layered, the pins connecting the layers could be arranged such that the Arduino and DWM1000 were essentially above each other (but without interfering with their pins, as before). See (INSERT FIGURE). In the end, this design was abandoned because the breakout pins would add to much vertical length, it was expensive, and because it was much more complex to design.

As such, the end design required the Arduino and DWM1000 to be spread out over the board, resulting in the PCB being quite long and narrow. The PCB design was done in Eagle and ordered from PCBWay. The result can be seen in (INSERT FIGURE).

\section{Arduino Software}


Go into our open source library to help with the use of the DWM by thotro. Talk about the protocol we made.

\section{DWM1000 Bugs}
Go into specific issues with calibrating antennae delay, with sending delayed transmissions, etc.

\section{Results}
Go into how accurate rangefinding is, operating frequency, etc. Have tables!

\section{Conclusion}
Talk about how we now have a subsystem which can fully handle calculating ranges between things.
