% Rangefinding

\chapter{Rangefinding} % Main chapter title

\label{Rangefinding}

%----------------------------------------------------------------------------------------

\section{Overview}
 Rangefinding is the act of determining the distance between two things.
 
\subsection{The System}
The rangefinding subsystem is comprised of \textbf{nodes} in a network, each of which is capable of sending and receiving wireless signals.

(PUT IN A DIAGRAM OF A NETWORK AND RANGES HERE)

Each node is either an \textbf{anchor} or a \textbf{tag}. Both tags and anchors use essentially the same hardware and code, but anchors are assumed to be stationary while tags are mobile. Stationary nodes are required so as to provide a consistent frame of reference for other nodes when calculating positions later on. More information on this can be found in !!!TO-DO INSERT LABEL!!!.

The rangefinding subsystem's purpose is to determine the distances between every pair of nodes in the network. With this data, the position calculation subsystem can then determine the positions of every anchor and tag in 3D space.

\subsection{Rangefinding}
Rangefinding is done wirelessly. The underlying concept is that if we can calculate the times at which we send and receive a signal, then - since light travels at a fixed speed - we can determine the distance the signal traveled, which is the distance between the nodes. 

The basic method is this: 
\begin{enumerate}
	\item Each node broadcasts a message to every other node, and every node responds. 
	\item The time it took for the message to travel from one node to another and then back (minus the time spent processing the received messages) is calculated.
	\item With some simple math involving the speed of light the distance between the nodes is calculated. 
\end{enumerate}

This method of calculating range is known as \textbf{time-of-flight} (TOF).

Each node is comprised of a DWM1000, can send wireless signals, and an Arduino microcontroller.

\subsection{Requirements}
There are a number of useful characteristics a rangefinding system should have:
\begin{itemize}
	\item Ranges should be accurate and not very noisy.
	\item Ranges should be calculated at a high frequency. If they are not, then we cannot calculate positions quickly and moving objects will have their positions displayed inaccurately.
	\item The system should be able to cover a large area. 
	\item The system should be robust to nodes entering/leaving the network. 
\end{itemize}

It will be demonstrated how we sought to satisfy these criteria.

(TODO TALK ABOUT WHAT IS COMING UP IN THE REST OF THE CHAPTER)

\section{Time-of-Flight}
This section briefly covers the math behind time-of-flight range calculations. For something more in-depth, the DWM1000 User Guide (INSERT CITATION HERE) has a comprehensive write-up of the different ways wireless ranging can be performed.

\subsection{Basic Two-Way Ranging}
In the case where there are two nodes communicating with each other, one can calculate the time it takes a signal to propagate between them, $t_p$, as:

\[
	t_p = \frac{t_{round} - t_{process}}{2}
\]

A diagram displaying this can be found in !!INSERT HERE!!.

\subsection{Asymmetric Two-Way Ranging}
Because the clocks of two nodes may not pass time at the same rate, the above equation will not be as accurate as possible. The DWM1000 User Guide presents, without proof, the following equation for more accurate rangefinding:

\[
	t_p = \frac{round_1  round_2 - reply_1 reply_2}{ round_1 + round_2 + reply_1 + reply_2}
\]

$round_1$, $round_2$, $reply_1$, $reply_2$ are respectively the total times taken (EXPLAIN BETTER HERE). See (INSERT FIGURE HERE).
 
A possible proof of this equation can be found in (INSERT APPENDIX THING HERE).

\section{Wireless Communications}
At the start of the project, it was determined that a technology would need to be chosen to handle wireless communications for ranging purposes. A number of options were considered. The ideal technology would:
\begin{itemize}
	\item Be inexpensive.
	\item Have good range for in-door use.
	\item Allow for extremely precise measurements of time. Due to the speed of light, a nanosecond of error in timing calculations would lead to approximately 30cm of error in the calculated distance.
	\item Be small. As tags are attached to cellphones, they must be small.
\end{itemize}

\subsection{Bluetooth in Phones: A Failed Approach}
Originally, the goal was to use Bluetooth for ranging. The reason for this was that Android cellphones, which usually have Bluetooth transceivers, could be used for tags and anchors. This would save a large amount of time, as cellphones include batteries, are easy to program, and almost everyone has one (which would make letting people use our project as easy as downloading an app). We would just need to put a few phones running our app around a room, and we'd get ranging.

Unfortunately, it became clear early on that Bluetooth - specifically, Bluetooth used on Android cellphones - was not suitable. There were two ways to use Bluetooth for ranging: 

\begin{itemize}
	\item RSSI (received signal strength indicator), which is essentially a measure of how strong a received signal is. Because signal power drops off with the square of distance, RSSI can be used to determine distance from a cellphone. Indeed, there this is a cellphone app to do just that on the Google Play Store. Measurements showed that this was method had very low range, was very noisy (power levels varied wildly), and had a large latency between measurements. As well, RSSI values are not standard among cellphones, requiring many calibrations for each model of phone used. Due to these factors, it was determined that using RSSI for distance measurements was not well suited for the fine-grained location tracking this project sought. 
	\item Time-of-flight measurements. Experiments showed that the time it took to send a Bluetooth message itself through the Android OS suffered massive variance of milliseconds (ADD IN APPENDIX CITATION WITH OUR CODE?), which would lead to 300 km of error in calculated distances! Android does not have any guarantees on timing, and does not allow low-level programming access to its internals. This method was proven unworkable.
\end{itemize}

With all the avenues to use Bluetooth exhausted, the idea of using phones and their Bluetooth transceivers was rejected.

\subsection{Ultra-wideband and the DWM1000}
After doing some research, we discovered the Decawave DWM1000 ultra-wideband transceiver. This chip is advertised as specifically being suited for ranging applications. It uses ultra-wideband technology rather than Bluetooth, Wi-Fi, or similar technologies.

Ultra-wideband, in contrast to Wi-Fi and other radio technologies, occupies a large bandwidth and transmits information via high-bandwidth pulses. Ultra-wideband is suited to tracking applications due to its resistance to multipath propagation, a phenomenon where signals reflect off of surfaces and thus reach the antennae via multiple paths (causing interference). An in-depth look at ultra-wideband is beyond the scope of this report, but interested readers might look more at (INCLUDE SOURCES HERE!!!).

The DWM1000 is advertised as:
\begin{itemize}
	\item Allowing one to locate objects with up to 10cm accuracy.
	\item Having a range of up to 290m.
	\item Having a data rate of up to 6.8Mb/s.
	\item Having a small physical size. 
\end{itemize}

As well, there was an already an open source library written to use it with an Arduino, which would allow us to quickly prototype with the chip and ensure it would fit for our application.

Because these qualities satisfied our requirements, the DWM1000 was chosen for the foundational technology of the ranging part of the project. 

\section{Design of the Hardware}
The hardware design for tags is an Arduino Pro Mini 3.3V connected to a DWM1000 over a PCB. 

\subsection{The Microcontroller}
To interface with the DWM1000, a microcontroller was needed. The Arduino Pro Mini 3.3V was chosen because:
\begin{itemize}
	\item Group members had previous experience with programming Arduinos.
	\item It was inexpensive.
	\item It worked off of 3.3V power, which was what the DWM1000 required. This obviated the need for voltage stepping.
	\item It is capable of floating point math, which is useful for asynchronous two-way ranging. As well, barely any processing power or RAM was needed. Each microcontroller only needed to hold a small number of timestamps, so the small amount of memory and slow processor was not important.
	\item Small physical size. As tags are attached to cellphones, they must be small.
	\item Batteries would not be needed to power tags, since power could be delivered via USB from the cellphone. This further simplified the design and kept costs low.
\end{itemize}

The only real downside of the Pro Mini was that it required a lot of soldering. 

\subsection{The PCB}
Several designs were considered for the PCB connecting the Arduino and DWM1000. The most important factor was size. A PCB was constructed only for the tags, and anchors - which did not need to be reduced in size - were left in breadboard form in order to save costs and time. Making alterations to the PCB design to allow for a barrel jack power adapter (the only distinguishing feature between tags and anchors) would, however, have been extremely simple.

The first design idea we tried was to place the Arduino and DWM on top of each other, resulting in the smallest possible size. See (INSERT FIGURE HERE). However, the physical dimensions of the two components made this impossible. The other possibility was to place each component on opposite sides of the PCB (INSERT FIGURE HERE), but the Arduino's design demanded breakout headers to solder it into the board, which meant the PCB had to have holes drilled. This essentially ran into the same problem as with the original.

The second idea was to make two PCBs. The Arduino would connect to a PCB above it, and that PCB would connect to a board above it with the DWM1000 it. Because it was layered, the pins connecting the layers could be arranged such that the Arduino and DWM1000 were essentially above each other (but without interfering with their pins, as before). See (INSERT FIGURE). In the end, this design was abandoned because the breakout pins would add to much vertical length, it was expensive, and because it was much more complex to design.

As such, the end design required the Arduino and DWM1000 to be spread out over the board, resulting in the PCB being quite long and narrow. The PCB design was done in Eagle and ordered from PCBWay. The result can be seen in (INSERT FIGURE).

\section{Arduino Software}
The software to control the DWM1000 was written in C++ in Arduino IDE. The basic code to control the DWM1000 (handling memory address constants, communication with it via SPI, and a few high-level functions like send/receive) was freely available in Thomas ``thotro'' Trojer's \texttt{arduino-dw1000} library. The library served as the foundation of our code to network the devices.

\subsection{Networking Basics}
Each node in the network broadcasts on a set schedule (MODIFY THIS LATER AFTER TIME SHARE SYSTEM IMPLEMENTED). It transmits a timestamp of when it sent the message, a list of the timestamps when it last received a communication from every other node in the network, and a list of the last computed ranges to the other nodes. Similarly, every other node in the network will receive this information and use it to compute a new range to the node in question. Thus, every node in the network will receive complete range information for the whole network.

The DWM uses 40 bits (5 bytes) for its timestamps. The Arduino internally represents these as 64-bit integers (the last byte being meaninless), but transmits them as 40 bit (5 byte) numbers.

Every node in the network has a pre-determined ID, which is set when it the code is programmed onto the device. A single byte is used for this ID to save as much space as possible, though the code could easily be modified to support longer IDs if the devices were to be mass produced. Alternately, something like DHCP could be implemented. As there are only 7 devices currently operational, our project only uses IDs 1 through 7.

Communications between the Arduino and the DWM1000 are handled through SPI. When the DWM1000 receives a message, it triggers an interrupt on the Arduino, which can then obtain the data through SPI. TO DO REWRITE THIS A BIT MAYBE.

\subsection{Range Information Protocol}
The protocol for a transmission from a node is as follows:

\begin{itemize}
	\item 1 byte for the ID of the transmitting node.
	\item 5 bytes for the timestamp of the sending of the message.
	\item For each device the transmitting node has knowledge of:
	\begin{itemize}
		\item 1 byte for the ID of the device
		\item 1 byte for the shared counter (used to detect lost transmissions)
		\item 5 bytes for timestamp of last received message from the device
		\item 4 bytes for last calculated range	
	\end{itemize} 
\end{itemize}

Parsing a received message and updating information from it is very simple. For the code in question, look at (INSERT APPENDIX HERE).

TALK ABOUT ROLLING TIMESTAMPS TO-DO!

\subsection{Calculating a Delay}
As part of the time of flight calculation, a timestamp is needed for when the message was received and for when the reply was sent. The DWM1000 does not offer a way to automatically set the time upon transmission, but does offer the ability to set a time when a message will be transmitted in the future. This timestamp can then be embedded in the message itself.

Ideally, this delay is short. However, if the delay is too short, the Arduino will not be able to transmit the data the DWM1000 should send before the timestamp is passed. This causes a silent error, and the DWM will not transmit anything. As well, the delay specified is not the delay at which the DWM1000 will begin transmitting, it is the delay that the DWM1000 will begin transmitting the data itself. There is a ``premable'' sent before any transmission to allow the other devices in the network time to wake up and begin sniffing the air and know a message is coming. This time to send the preamble lasts quite a long time (approximately 1 microsecond per symbol in the problem (ADD CITATION HERE), which adds up to almost 2 ms). This was the most difficult to solve bug that was encountered in the design of the system.

In the code, the minimum delay before we can transmit is the sum of the:
\begin{itemize}
	\item Number of symbols in the preamble $\times$ 1\si{\micro\second} (UPDATE THIS FOR THE FINAL VERSION WITH THE LENGTH OF THE PRAMBLE)
	\item Time required to calculate and send the timestamp using SPI, about 1000\si{\micro\second} (empirically determined)
	\item Bytes of data to transmit $\times$ 4.5\si{\micro\second}, or 85 $\times$ number of devices in the network besides this one (empirically determined)
	\item A fudge factor just in case of about 200\si{\micro\second}
\end{itemize}

It is important to minimize this delay so to increase the maximum frequency the system can update ranges at.

\subsection{Communications Timing}
Go into the timeshare system when it is done. 

\section{System Operating Frequency}
Go into the math of how many updates per second can make, talk about how more devices on the network reduces this.

\section{Calibrating}
DWM1000s need to be calibrated to give correct distances due to the differences in hardware. There are a number of factors affecting the DWM1000, such as temperature. Some of these factors are controlled for in software in the arduino-dw1000 library. For a detailed overview of the possible errors and how to correct for them, consult the INCLUDE SOURCE HERE IT WAS A PDF ON THE SITE I READ.

The primary factor which could not be controlled for by Decawave is the antenna delay. The capacitance of the hardware the DWM1000 is hooked up to can cause nanosecond-level delays in transmission (in experiments, it was found that this could cause up to several meters of error incorrectly configured). This is a constant, and is determined empirically. The antenna delay for the tags is the same and was found to be INSERT NUMBER HERE THAT WE FOUND, and the antenna delay for the anchors is roughly the same and was found to be INSERT NUMBER HERE.

These constants required a slight tweak to the DWM1000 library. INSERT LINK TO SOURCE CODE OF OUR CHANGED VERSION HERE.

\section{Results}
Go into how accurate rangefinding is, operating frequency, etc. Have tables!

\section{Conclusion}
Talk about how we now have a subsystem which can fully handle calculating ranges between things.
